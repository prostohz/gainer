# Beta расчет через фильтр Кальмана

## Преимущества фильтра Кальмана над классической регрессией

### 1. Адаптивность

- **Классическая регрессия**: Вычисляет статический коэффициент beta для всего периода
- **Фильтр Кальмана**: Динамически адаптируется к изменениям рыночных условий

### 2. Обработка шума

- **Классическая регрессия**: Чувствительна к выбросам и рыночному шуму
- **Фильтр Кальмана**: Фильтрует шум и сглаживает оценки beta

### 3. Скорость адаптации

- **Классическая регрессия**: Требует достаточно данных для стабильной оценки
- **Фильтр Кальмана**: Начинает давать полезные оценки с первых наблюдений

### 4. Обработка временных рядов

- **Классическая регрессия**: Предполагает стационарность данных
- **Фильтр Кальмана**: Специально разработан для нестационарных временных рядов

## Параметры фильтра

### Process Noise (Q)

- **Назначение**: Контролирует скорость адаптации к изменениям
- **Малые значения (1e-5)**: Медленная адаптация, стабильные оценки
- **Большие значения (1e-3)**: Быстрая адаптация, более чувствительные оценки

### Measurement Noise (R)

- **Назначение**: Учитывает шум в наблюдениях
- **Малые значения**: Больше доверия к наблюдениям
- **Большие значения**: Меньше доверия к наблюдениям, больше сглаживание

## Применение в торговле

### Парный трейдинг

- Более точная оценка hedge ratio между коррелированными активами
- Адаптация к изменяющимся рыночным условиям

### Риск-менеджмент

- Динамическое хеджирование портфеля
- Адаптивные стоп-лоссы основанные на изменении корреляций

### Арбитраж

- Более точное определение моментов расхождения/схождения цен
- Адаптация к изменениям волатильности

## Пример использования

```typescript
const betaHedge = new BetaHedge();

// Адаптивная оценка beta для всей серии
const currentBeta = betaHedge.calculateBeta(candlesETH, candlesBTC);

// Скользящая оценка beta для анализа динамики
const rollingBetas = betaHedge.rollingBeta(candlesETH, candlesBTC, 50);
```

## Технические детали

- Модель состояния: beta коэффициент (скаляр)
- Модель наблюдения: returnB = beta \* returnA + noise
- Инициализация: beta = 1.0, P = 1.0
- Обновление через стандартные уравнения фильтра Кальмана
